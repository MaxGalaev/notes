Redis это сервер баз данных типа ключ-значение, который хранит данные в оперативной памяти. Он поддерживает большое кол-во разных типов данных из коробки, например строки, списки, хеш-таблицы, множества и т.п.. 

Redis написан на C и является однопоточным приложением, но работает очень быстро. Используется в разных сценариях, чаще всего как кеш для данных которые редко меняются но нужны часто. Либо для данных, которые не являются критичными и часто меняются. 

Несмотря на то, что данные хранятся в оперативной памяти, существуют 2 механизма сохранения данных на диск. RDB (redis database) и AOF(append-only file). Первый используется для создания снимков состояния баз и работает по расписанию. Второй пишет в лог все операции с базами, которые потом можно проиграть заново и получить все данные. 

Redis может работать как в одиночном режиме так и в нескольких режимах кластера.

#### Высокая доступность
Самый простой вариант развертывания в режиме высокой доступности это создание дополнительных копий сервера и репликации данных с мастера. Дополнительные копии(Slave) доступны только на чтение. Автоматического файловера нет.

Второй вариант это использования Redis в режиме Sentinel. По сути, это тот же Redis-server запущеный рядом, который следит за выбором мастера. Если мастер умрет, Sentinel запустит выборы нового мастера, поэтому число запущенных сервисов Sentinel должно быть нечетным. В идеале 3 или больше серверов Redis и Sentinel работающих вместе.  Клиенты должны уметь работать с Sentinel. Проблема в том, что клиенты должны сами спрашивать у Sentinel кто сейчас мастер и подключаться к нему. Это можно решить используя например HAPROXY, предоставляя клиентам один ip. 

Ну и наконец, собственно кластер. Конфигурация, которая представляет собой горизонтально масштабируемую сеть, в которую входит множество клиентов и пар «ведущий — зависимый узлы». 
За мониторинг в схеме отвечает протокол Gossip — он отслеживает состояние узлов системы и перераспределяет права, если ведущий узел перестает отвечать. Так достигается высокий уровень отказоустойчивости системы.
Механика работы Redis Cluster отличается от механизмов, реализованных в схемах HA и Sentinel. Так, в Redis Cluster основой является шардирование, а не репликация, что подразумевает сегментирование данных и распределение нагрузки по элементам кластера и, как результат, снижение нагрузки на БД.

Для Redis важной настройкой является размер оперативной памяти  и политики вытеснения. 

Политика вытеснения (maxmemory-policy) — это алгоритм, по которому Redis освобождает память, когда ее фактическое использование в кластере достигает максимально доступного объема (maxmemory).

По умолчанию Redis может использовать всю оперативную память сервера. Параметр **maxmemory** позволяет задать ограничения для оперативной памяти, которую может использовать Redis.

## Список политик⁠

- volatile-lru — удаляет ключи с истекшим сроком действия по аппроксимированному алгоритму LRU;
- allkeys-lru— удаляет любой ключ по аппроксимированному алгоритму LRU;
- volatile-lfu — удаляет ключи с истекшим сроком действия по аппроксимированному алгоритму LFU;
- allkeys-lfu — удаляет любой ключ по аппроксимированному алгоритму LFU;
- volatile-random — удаляет случайный ключ с истекшим сроком действия;
- allkeys-rando — удаляет любой случайный ключ;
- volatile-ttl — удаляет ключ с более коротким временем жизни (меньшим TTL);
- noeviction — не удаляет ключи, просто возвращает ошибку при операциях записи.